# study
# 工作中学习的小案例

### 简单实现一个中间数据的传输层
- 基于ArrayBlockingQueue
- 通过自定义的格式进行数据的写入和写出

### mysql load 方式导入大批量的数据
- 创建测试表
- 实现自定义的inputStream
- 通过load方式导入
- 借助中间传输层实现一个小demo

### netty实现im案例
- 客户端服务端启动类
- 定义通信协议
- 实现序列化和编解码
- 拆包粘包的实现
- 互聊
- 群聊
- 心跳


### 线程池的使用
- 自定义线程池


### 算法
- 排序算法
- 二分查找


### kafka 学习 版本 0.9.0.1
- 生产者
- 三种语义的消费模型
- 参数 max.partition.fetch.bytes,batch.size

### es的使用  新闻搜索案列
- 索引mapping 建立
- api的使用
- 修改了结构后，重新索引数据
- 别名的使用
````
创建别名
PUT /comet_v1/_alias/comet

查看信息
GET /*/_alias/comet

重新索引别名
POST /_aliases
{
    "actions": [
        { "remove": { "index": "comet_v1", "alias": "comet" }},
        { "add":    { "index": "comet_v2", "alias": "comet" }}
    ]
} 
````

### wait notify VS lock&condition
- 锁使用的变化学习
````
条件队列可以让一组线程（叫做：等待集wait set）以某种方式等待相关条件变为真，条件队列的元素不同于一般的队列，
一般队列的元素是数据项，条件队列的元素是线程。每个java对象都有一个内部锁，同时还有一个内部条件队列。
一个对象的内部锁和内部条件队列是关联在一块的。Object.wait会自动释放锁，并请求os挂起当前线程，
这样就给其他线程获得锁并修改对象状态的机会，当线程被唤醒以后，它会重新去获取锁。调用wait以后，
线程就进入了对象的内部条件队列里面等待，调用notify以后，就从对象的内部条件队列里面选择一个等待线程，唤醒。 
因为会有多个线程因为不同的原因在同一个条件队列中等待，因此，用notify而不用notifyAll是危险的！有的线程是在take()的时候阻塞，
它等待的条件是队列不空，有的线程是在put()的时候阻塞，它等待的条件是队列非满。 
如果调用了take()以后notify的是总是阻塞在take上的线程，就挂了！

从空变为了非空，唤醒的应该是那些阻塞在take()上的，从满变为了不满唤醒的应该是那些阻塞在put()上的线程，
而notifyAll会把所有条件队列里面的所有的等待的线程全部唤醒，
这就显现出了内部条件队列有一个缺陷：内部锁只能有一个与之关联的条件队列。显式的condition的出现就是为了解决这个问题。

正如Lock提供了比内部锁更丰富的特征一样，condition也提供了比内部条件队列更丰富更灵活的功能。
一个lock可以有多个condition，一个condition只关联到一个Lock。
````


### 工具类使用
- shell
- resources











